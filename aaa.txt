郭君宇 - 郭小闹
88年12月 
11年本科计算机 - python - 游戏&


前端 - 数据的显示 
后端 - web-接请求 返响应 

后端课程体系： 
8.5天 Django课程 
3天  redis 数据库 
2天  ajax 技术
7天  项目课

要求: 复习是必然的 【前置阶段知识】
      
			1，项目经理 - 
			2，250919354@qq.com 
			   中心名称-班级-姓名-问题-性别

北京 - 后端
 16-19年
  校招
	max 22k - 24k  
  本科 - 9K
	研究生 - 12K “不封顶”

  社招
	1-3年 10 - 20K

刷题 - 构建编程思维  
  
    剑指offer - 牛客网  - 非数据结构 30%
    leetcode

day01回顾
 初识Django - web框架 - 重度框架
 
 创建项目 - django-admin startproject 项目名

 启动 - python3 manage.py runserver
 停止 - ctrl + c

 组成 - manage.py   同名文件夹

 settings.py - 配置文件

 URL-全貌  

    -路由

 Django - 路由系统
  1， 主路由 - ROOT_URLCONF
	2， 加载主路由 urlpatterns变量
	3， urlpatterns = [ path, path,..]
	    path('route', 'views')
  4,  将匹配到的请求，传递给path的第二个参数【视图函数】处理
	5， 没匹配成功 - 404响应


 视图函数 
    1， 同名文件夹下，手动创建views.py
		[跟urls.py平级]
		2， 参数 - request 
		    return - HttpResponse()

 path('route', views, name=‘别名’)
	‘page/页码’ - 如何灵活匹配
	 
 path转换器
   ‘page/<int:pg>’ - 转换器匹配到值，则按关键词传参的方式 将值 传递给视图函数

 re_path转换器 
   ‘page/(?P<分组名>表达式)’ 匹配到值，则按关键词传参的方式 将值 传递给视图函数
   ps: 传递到视图函数的值均为字符串类型


 HTTP协议的请求和响应
    1， 请求 -> 包含了用户的 ‘所思所想’
		    视图函数 第一个参数 - request
        
				request.属性/方法
		
		2， 响应

day02回顾
  1， HTTP请求和响应 
		响应 - 状态码 200 500 301/302【Location响应头】

    django-响应 HttpResponse(响应体，CT，状态码)

    Content-Type 请求、响应头

 2，Django GET 和 POST处理
    
		GET - 获取数据用
		      地址栏、超链接， form-get
					查询字符串 【传递少量数据给服务端, 在GET中会大量使用】
					topic/xiaoshuoming?p=1&z=1
        
				  request.GET

		POST - 提交数据用
           表单提交 form-post
					request.POST
          PS: 关闭csrf的检查，否则403响应；settings.py中 禁止掉相关配置
 3，设计模式
		MVC vs MTV
		MTV - V 什么数据要去显示
		      T 如何、怎样显示数据
					M 跟数据库通信的桥梁
		
 4，模板层（T）
      能解析 - 视图传递给html的数据 
    
      配置： 1,项目目录下 配置文件夹templates - 存放html
			       2,settings.py TEMPLATES
						 os.path.join(BASE_DIR, '文件夹名')

      代码：1，加载 return render(request, 'xxx.html')
            2，数据 将包含数据的字典放在render 第三个参数
            3，html - {{ 变量 }}
						          {% 标签 %}
                      {% 结束标签 %}

      XSS攻击 - django在模板层 默认开启了html转义，有效防止xss；视图-import html html.escape()


day03回顾
   标签 - for 
	 过滤器 - {{ 变量|过滤器:'参数' }}
   模板继承
        子模板可以继承父模板的内容，将之重用，且子模板按需的对父模板的内容做修改
				1，父 - 定义样式 定义可修改的部分- {% block blockname %}{% endblock %} 
				2，子 - 1,继承 {% extends '父模板文件名' %}
				        2，按需修改 block
				ps:父模板中的动态数据，无法继承

   url反向解析
       
			 根据path/re_path name参数，动态反射出 真实的url
       
			 模板 
			   {% url ‘别名’ ‘参数1’ %}
			 视图
         from django.urls import reverse
				 reverse('别名', args=[], kwargs={})

   静态文件 -  img css js
      settings.py 配置
			1，STATIC_URL - 告知django 什么样的请求是 加载静态文件的请求
			‘/static/’

      2, STATICFILES_DIRS = (os.path.join(BASE_DIR, '文件夹名')， )
         - 告知django 静态文件存储在哪里

			3，img src='/static/ + 存储路径'
	       {% load static %}
				 {% static '存储路径' %}

   Django应用 - app
	 解耦原有的结构，按功能拆分应用，每个应用独立的.... MTV
   1，先创建 - python3 manage.py startapp 应用名
	 2，再注册
      settings.py INSTALLED_APPS = []

   T层手动创建 - templates
   小心文件冲突 - 创建和应用同名文件夹
	 视图 - render(request, '文件夹/xx.html')

   分布式路由 - 主路由 只匹配url前缀(include('应用名.urls'))
	              子路由 匹配后缀
   
   模型层 - M

	 django 2.0以上 mysqlclient 1.3.13以上
   1，C版本 - sudo apt
	 2, Py版本 - sudo pip3

   按项目去创建数据库 - 数据库名 跟项目名保持一致 - default charset utf8
	  
	 django数据库的配置 


day04回顾

  1，模型类定义 - 
	    1，字段
			2，字段选项 [私有的，通用的]
  
	2，makemigrations - 生成迁移文件
	   migrate - 将迁移文件同步到数据库
		 PS:只要模型类修改，执行上述命令
     mysql - django_migrations - 记录了项目执行过的迁移文件

  3，增删改查
     模型类.管理器对象[objects].xxx
     django shell调试M层 - 只要M层代码有变化，记得重启shell,方能将最新代码生效
 
     1,增 -
		    1， objects.create(属性=值 )
        2， obj = 模型类(属性=值)
				    obj.save()

     2，查 
		    查询接口
				全量查询 - 无where
				  all            Q   obj
					values         Q   {}  
					values_list    Q   ()
        排序 - order_by('-字段')

        条件查询
				   filter       Q   obj
					 exclude      Q   obj
					 get          obj  - 易报错
         
        条件玩法 - 查询谓词 - 字段名__谓词

				聚合函数
					1，整表
					   1）导入聚合函数
						 2）aggregate(结果变量名=聚合函数('列')) -> {结果变量名:聚合结果}
					2，分组
							1）导入聚合函数
							2）分
							    Q = values('分组列')
							3）聚
									Q.annotate(同整表聚合)
									结果-> Q -> 可继续执行filter
			
			3，更新
         1，单
				    1）查
						2）obj.xx = xxx 改
						3）obj.save()
				 2，多
						Q.update(字段=值)
			4，删除
				真删  delete
				伪删  is_active=True, True -> False


day05回顾

	F对象 & Q对象
	F : 代表数据库中某条记录的字段的信息
	    F('列')

  Q : 或 与 非 的 条件查询
     Q(条件1)|Q(条件2)
		 Q(条件1)&~Q(条件2)  与非

	原生SQL语句 - 谨防sql注入
  PS : 尽量不要使用用户的输入 去 拼接SQL语句

  1，模型类.objects.raw(sql语句，[拼接参数]) - 查
  2，直接使用数据库的连接进行操作
	    - 增删改查
			from django.db import connection
      with connection.cursor() as cur:
			    cur.execute(sql语句， [拼接参数])

	admin - 管理后台
		1，创建超级用户账号
		2，/admin/
    3, 按需的注册我们自定义的模型类
			 admin.py --- register
    4, 模型管理器类 - 增强我们自定义的模型类在admin中的效果
			 admin.py -- admin.ModelAdmin
			 绑定注册给指定的模型类 -- register

	关系映射
  
		1， 一对一

			class A
			class B
			   a = models.OneToOneField(A, on_delete=models.CASCADE)

       外键属性名 - 创建数据要有要求，
			 需要指定 obj
			 外键字段名 - 创建数据要有要求，
       需要指定 值

			 查询 - 
			 正向
			   有属性的查 没属性的
         b1.a -> obj

			 反向
				 a1.b -> obj

		2， 一对多
      class A (一)
			class B (多)
			   a = models.ForeignKey(A, on_delete=models.CASCADE)
			
			创建 - 同1对1
			查询 - 
				正向
          b1.a

				反向
					a1.b_set.all()...


		3， 多对多
				
				class A
				class B
				   as = models.ManyToManyField(A)

				创建数据
				a1.b_set.create
				a1.b_set.add

				查询 
				  正向
						b1.as -> objects
					反向
            a1.b_set -> objects

	Cookies 和 session
   
	  会话状态的保持

day06 回顾
  
	会话保持技术 - Cookies 和 session

	Cookies vs session
 
  Cookies - 存储在了浏览器
  session - 存储在服务器里【Django-数据库里】 借助Cookies

  问题：1，单表 - clearsessions 
        2, Cookies里的sessionid 
   

day07回顾

	缓存-通过更快的存储介质获取数据
	后端缓存
     1，响应直接存储缓存里
					cache_page(30)
     2, 局部的按需存储
		      cache缓存对象
          cache.set()/get()

	 前端（浏览器）缓存：
     正常获取数据 - http请求 - 服务器
		 缓存 - 不发请求，直接通过本地相关的存储返回数据给用户

		 强缓存  -  
				响应头 - Expires
                 Cache-Control
				响应中出现上述响应头，浏览器直接将当前响应 存入缓存，下次用户再访问该地址时，直接返回用户缓存数据【不发请求】 - cache_page

		 协商缓存 - 针对静态文件
     1，如果强缓存到期后，改文件没有变化，则考虑不从服务器获取内容
		 2，响应头 Last-Modified 文件修改时间
               Etag 文件唯一标识

		 3，有上述响应头的响应内容，一旦缓存到期，浏览器会发出 协商请求
				请求头 if-Modified-Since
				       if-None-Match

     4, 文件没修改 - 304响应 响应体为空
		          修改 - 200响应 响应体为最新资源的数据

	中间件 - 钩子 全局改变django的输入和输出
			1，中间件类
			2，五个方法 - 每个方法都有特定的调用时机 【按需定义】
			3，编写完中间件类之后，记得注册中间件

   csrf攻击： 伪造你的登录身份 Cookies[自动提交]
            防范 模板中 {% csrf_token %}
         
	 csv下载 
	     1，改content-type text/csv
			 2, 加响应头 Content-Disposition:"attachment;filename='xxx.csv'"
			 3, 查数据
			 4，writer = csv.writer(response)
			 5, writer.writerow([])


day08回顾

   1，分页 
	    paginator对象
			  p = Paginator(object_list, per_page)
				职责：宏观管控 - 分多少页，负责初始化page对象
			page对象
         page = p.page(页码)
         职责：微观管控 - 当前页码的负责人，当前页有哪些数据，当前页有没有上一页或下一页。。。

		2，django认证系统
       admin管理后台自带的用户表
			 create_user . .
			 set_password...
       扩展字段 - 第一次migrate之前

    3，文件上传
			1，前端
					post
					form - enctype='multipart/form-data'
					input - type='file' name=''
			2，后端
					file input  request.FILES['name']
					常规 input
					request.POST['name']

					写入方案
          1， open方案
					2， orm方案
              
							models.FileField(upload_to='子目录名')
              
							MEDIA_URL = '/media/'
							MEDIA_ROOT = '存储目录'

              主路由 手动绑定 上述配置


    4，电子邮件 - 配置

		5，项目部署

			1，uWSGI 替代 runserver
  
	       uWSGI 具备 网络IO + WSGI规范

      2， nginx - web服务
             转发http请求【反向代理】
						 负载均衡


















        














































  






   















	      



	
	   



















